<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="app_name">Kotlin Free</string>
	<string name="lessons">Уроки</string>
	<string name="lessons1">Часть 1</string>
	<string name="lessons2">Часть 2</string>
	<string name="lessons3">Часть 3</string>
	<string name="lessons4">Часть 4</string>
	<string name="powered_by_aide">Powered by Aide</string>
	<string name="changelog">История изменений</string>
	<string name="preferences_title">Настройки</string>
	<string name="preferences_title_app">Приложение</string>
	<string name="preferences_title_language">Язык</string>
	<string name="preferences_summary_language">Выберите язык приложения</string>
	<string name="preferences_title_about">О приложение</string>
	<string name="preferences_summary_about">Информация о приложение</string>
	<string name="changelog_p">
		"<b>V17.0-21.09.18</b>"
		"<b>New</b>":
		Уроки:
		• Getters и Setters(en/ru)
		• Первичный конструктор(en/ru)
		• Блок инициализатора(en/ru)
		
		"<b>V16.0-9.09.18</b>"
		"<b>New</b>":
		Уроки:
		• Классы(en/ru)
		• Свойства(en/ru)
		• Функции-члены(en/ru)
		Fix:
		• Настройки
		
		"<b>V15.0-2.09.18</b>"
		"<b>New</b>":
		Уроки:
		• Параметры функции(en/ru)
		• Аргументы функции по умолчанию(en/ru)
		• Проверка типов и автоматическое копирование(en/ru)
		• Неверные типы(en/ru)
		Настройки:
		• Выбор языка
		
		"<b>V14.0-18.08.18</b>"
		"<b>New</b>":
		• Новый интерфейс
		• Добавлен украинский язык
		
		"<b>V13.0-17.08.18</b>"
		"<b>New</b>":
		Уроки:
		• Использование циклов с массивами(ru)
		• Время практики: Циклы и Массивы(en/ru)
		• Функции(en/ru)
		
		"<b>V12.1-16.08.18</b>"
		"<b>Fix</b>":
		• Тема для sdk 14-20

		"<b>V12.0-15.08.18</b>"
		"<b>New</b>":
		Уроки:
		• Цикл for(en/ru)
		• Использование циклов с массивами(en)

		"<b>V11.0-3.08.18</b>"
		"<b>New</b>":
		Уроки:
		• Массивы(en/ru)
		• Итералы(en/ru)

		"<b>V10.1-27.07.18</b>"
		"<b>New</b>":
		Код:
		• Шрифт monospace
		• HorizontalScrollView

		"<b>V10.0-25.07.18</b>"
		"<b>New</b>":
		Уроки:
		• Цикл while(en/ru)
		• Цикл do-while(en/ru)
		• break и continue(en/ru)

		"<b>V9.0-20.07.18</b>"
		"<b>New</b>":
		Уроки:
		• Выражение when(en/ru)
		"<b>Fix</b>":
		• Русский язык
		• Английский язык

		"<b>V8.0-15.07.18</b>"
		"<b>New</b>":
		Уроки:
		• Логические операторы(en/ru)
		"<b>Fix</b>":
		• Русский язык

		"<b>V7.0-25.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Операторы: if и else(en/ru)
		• Операторы: if-else-if(en/ru)

		"<b>V6.0-22.06.18</b>"
		"<b>New</b>":
		• История изменений
		Уроки:
		• Инкремент и декремент(en/ru)
		• Строковые шаблоны(en/ru)
		• Время практики: основа(en/ru)

		"<b>V5.1-21.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Вывод(ru)
		• Ввод(ru)
		• Комментарии(ru)
		• Арифметические операции(ru)

		"<b>V5.0-18.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Вывод(en)
		• Ввод(en)
		• Комментарии(en)
		• Арифметические операции(en)

		"<b>V4.0-15.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Литералы и константы(en/ru)

		"<b>V3.0-15.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Символы и строки(en/ru)

		"<b>V2.0-14.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Базовые типы(en/ru)

		"<b>V1.2-13.06.18</b>"
		"<b>New</b>":
		• Подсветка кода

		"<b>V1.1-13.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Добро пожаловать в Kotlin!(ru)
		• Базовый синтаксис(ru)
		• Переменные(ru)

		"<b>V1.0-12.06.18</b>"
		"<b>New</b>":
		Уроки:
		• Добро пожаловать в Kotlin(en)
		• Базовый синтаксис(en)
		• Переменные(en)</string>
	<string name="lesson1_title">Добро пожаловать в Kotlin!</string>
	<string name="lesson1_p"><b>Kotlin</b> - это <b>статически типизированный</b>" язык программирования, который запускается на виртуальной машине Java.

		Kotlin - полностью поддерживаемый язык программирования "<b>Google</b>" в операционной системе Android и был объявлен официальным языком разработки Android в Google I/O 2017.
		Kotlin может использоваться для разработки backend.

		Kotlin использует агрессивный тип вывода для определения типа значений и выражений, в которых тип остался неизменным. Это уменьшает языковую детализацию по сравнению с "<b>Java</b>.</string>
	<string name="lesson1_hint">Стандартная библиотека Kotlin предназначена для взаимодействия с Java-кодом и зависит от кода Java и от существующей библиотеки классов Java.</string>
	<string name="lesson2_title">Базовый синтаксис</string>
	<string name="lesson2_p">"Давайте начнем с создания простой программы, которая выводит на экран текст Hello, World!: "</string>
	<string name="lesson2_p2">"Давайте разберём код:

		\u0009\u0009Каждая программа Kotlin должна иметь определенную функцию "<b>main</b>, которая является отправной точкой для программы и выполняется с помощью ключевого слова <b>fun</b>".
		Функция "<b>println()</b>" используется для генерации вывода. В нашем случае мы передали сообщение для вывода в двойных кавычках функции.

		Теперь поработайте с кодом и попробуйте напечатать своё имя."</string>
	<string name="lesson2_hint">В большинстве случаев нет необходимости в точке с запятой, поскольку Kotlin предоставляет «вывод точки с запятой». Попробуйте запустить код без точки с запятой в конце инструкции <b>println()</b>.</string>
	<!--3-->
	<string name="lesson3_title">Переменные</string>
	<string name="lesson3_p">Объявление переменных выполняется с помощью <b>var</b> или <b>val</b>. <b>val </b> нельзя переназначить (он называется <b>неизменяемым</b>").
		Пример:"</string>
	<string name="lesson3_p2">Присвоение нового значения <b>num</b> или <b>str</b>" приводит к ошибке компиляции.
		Следующий код не будет компилироваться:"</string>
	<string name="lesson3_p3">Ключевое слово <b>var</b> позволяет объявлять переменные, которые можно переназначить:</string>
	<string name="lesson3_p4">"Как вы можете видеть, мы явно не задали тип переменных. Переменные получают соответствующий тип благодаря Kotlin's "<b>type interference</b>", где тип автоматически выбирается из значения, присвоенного переменной.

		Чтобы явно указать тип переменной, используйте следующий синтаксис:"</string>
	<string name="lesson3_hint">Приведенный выше код объявляет переменную <b>num</b> типа <b>Int</b> и <b>str</b> переменной типа <b>String</b></string>
	<!--4-->
	<string name="lesson4_title">Базовые типы</string>
	<string name="lesson4_p">"Kotlin - это статически типизированный язык программирования с поддержкой базовых типов данных, таких как Numbers, Characters, Booleans, Arrays, and Strings.

		\u0009\u0009Numbers представлены следующими встроенными типами:
		\u0009\u0009- Double
		\u0009\u0009- Float
		\u0009\u0009- Long
		\u0009\u0009- Int
		\u0009\u0009- Short
		\u0009\u0009- Byte
		\u0009\u0009Давайте объявим "<b>Integer</b> и выведем его значение:</string>
	<string name="lesson4_p2">"Типы number отличаются объемом памяти, который они выделяют:
		"<b>Byte</b> выделяет <b>1 байт</b>" памяти.
		"<b>Short</b> составляет <b>2 байта</b>",
		"<b>Int</b> составляет <b>4 байта</b>",
		"<b>Long</b> позволяет хранить <b>8 байтов</b>" данных.
		Если вам нужно сохранить значение с "<b>плавающей точкой</b>, например, 3.14, вы можете использовать Float или Double.</string>
	<string name="lesson4_p3">Обратите внимание на <b>f</b> после 3.14. По умолчанию Котлин интерпретирует числа с плавающей запятой как <b>Doubles</b>, которые имеют более высокую точность по сравнению с <b>Floats</b>".
		Чтобы объявить литерал Float, вы должны явно указать компилятору, что ваше значение Float, добавив "<b>f</b> в конце значения.</string>
	<string name="lesson4_hint">Для представления логических значений (true, false) используется тип <b>Boolean</b>.</string>
	<!--5-->
	<string name="lesson5_title">Символы и строки</string>
	<string name="lesson5_p">Символы представлены типом <b>Char</b>.</string>
	<string name="lesson5_p2">Набор символов представлен типом <b>String.</b>"
		Давайте объявим переменную "<b>String</b> и выведем её значение:</string>
	<string name="lesson5_p3">В таких языках, как C ++, символы неявно рассматриваются как числа, однако в Kotlin это не так.</string>
	<!--6-->
	<string name="lesson6_title">Литералы и константы</string>
	<string name="lesson6_p">"Литералы относятся к фиксированным значениям, которые программа не может изменять при её выполнении.

		\u0009\u0009Они могут быть любого из основных типов данных, таких как целочисленная константа, плавающая константа, символьная константа или строковый литерал."</string>
	<string name="lesson6_p2">"Kotlin поддерживает следующие литералы для интегральных значений:

		\u0009\u0009- Decimals: "<b>123</b> (Longs are tagged by a capital <b>L</b>: <b>123L</b>")
		- Hexadecimals: "<b>0x0F</b>"
		- Binaries: "<b>0b00001011</b></string>
	<string name="lesson6_hint">Литералы октальных чисел (восьмеричные числа) не поддерживаются в Kotlin.</string>
	<string name="lesson6_p3">Вы можете использовать символы подчеркивания, чтобы сделать числовые константы более удобочитаемыми:</string>
	<string name="lesson6_p4">Поскольку числа с плавающей запятой по умолчанию интерпретируются как Double, Floats помечены тегами <b>f</b> или <b>F</b>.</string>
	<!--7-->
	<string name="lesson7_title">Вывод</string>
	<string name="lesson7_p">Вывод в Kotlin может быть выполнен с использованием функции <b>println</b>.</string>
	<string name="lesson7_p2"><b>println()</b> автоматически добавляет <b>новую строку</b>" в конце вывода.
		"<b>print()</b> может использоваться для вывода без новой строки:</string>
	<string name="lesson7_p3">Чтобы включить значение переменной в строку, мы можем использовать либо оператор <b>+ (плюс)</b> или <b>строковые шаблоны</b>", который начинается со знака доллара ($). Ознакомьтесь с приведенными ниже примерами: "</string>
	<string name="lesson7_p4">Строковые шаблоны могут включать выражения в <b>фигурные скобки</b>".
		Пример:"</string>
	<!--8-->
	<string name="lesson8_title">Ввод</string>
	<string name="lesson8_p">Простым способом чтения со стандартным вводом является функция <b>readLine()</b>:</string>
	<string name="lesson8_hint">Все, что пользователь вводит автоматически, преобразуется в <b>String</b>.</string>
	<string name="lesson8_p2">Чтобы преобразовать ввод целого числа, используйте функцию <b>toInt()</b>:</string>
	<string name="lesson8_p3"><b>!!</b> подразумевает, что ввод не может вернуть <b>null</b>, что необходимо для ввода чего-то. <b>null</b>" означает отсутствие ценности.

		Такая же логика работает для Double и других типов, используя "<b>toDouble()</b> и аналогичные функции.</string>
	<!--9-->
	<string name="lesson9_title">Комментарии</string>
	<string name="lesson9_p">"Комментирующий код - хорошая практика, помогая вам и вашим коллегам-программистам понять и улучшить код.

		\u0009\u0009В Kotlin есть два типа комментариев: "<b>single-line</b> комментарии и <b>multi-line</b>" комментарии.

		"<b>Single-line</b> комментарии начинаются с двух косых черт(//). Всё после них игнорируется компилятором:</string>
	<string name="lesson9_p2">"Комментарии разъясняют намерение программы читателю.


		"<b>Multi-line</b> комментарии могут охватывать несколько строк. Они начинаются с косой черты и звездочкой, заканчиваются звездочкой и косой чертой(/* */):</string>
	<string name="lesson9_hint">Комментирующий код - хорошая практика. Это помогает объяснить код вам и другим программистам, читающим ваш код.</string>
	<!--10-->
	<string name="lesson10_title">Арифметические операции</string>
	<string name="lesson10_p">"Kotlin поддерживает следующие арифметические операции:

		\u0009\u0009+ (сложение)

		\u0009\u0009- (вычитание)

		\u0009\u0009* (умножение)

		\u0009\u0009/ (деление)

		\u0009\u0009% (модуль)


		\u0009\u0009Эти операции "<b>бинарные</b>, что означает, что они работают с <b>двумя операндами э</b>".

		Приведенный ниже код объявляет две целые переменные и выводит их сумму, используя оператор + (сложение):"</string>
	<string name="lesson10_title2">Деление</string>
	<string name="lesson10_p2">Оператор деление <b>(/)</b>" приводит к целому числу, удаляя любой остаток.
		Пример:"</string>
	<string name="lesson10_p3">"Чтобы получить остаток от деления, используйте оператор  % "<b>(модуль)</b>".
		Пример:"</string>
	<string name="lesson10_p4">Оператор <b>(модуль)</b> не может применяться к числам с плавающей запятой, однако оператор деления работает со значениями с плавающей запятой и приводит к результату с плавающей запятой:</string>
	<string name="lesson10_hint">Деление на ноль создает исключение.</string>
	<!--11-->
	<string name="lesson11_title">Инкремент и декремент</string>
	<string name="lesson11_p">Оператор <b>инкремента ++</b>" используется для увеличения значения переменной на единицу.
		Пример:"</string>
	<string name="lesson11_p2">Аналогично, оператор <b>декремента --</b> используется для уменьшения значения переменной на единицу.</string>
	<string name="lesson11_p3">Оба оператора инкремента и декремента имеют <b>prefix</b> (до имени переменной) и <b>postfix</b>" (после имени переменной).

		Форма "<b>prefix</b> увеличивает эту переменную и затем использует ее в операторе присваивания.</string>
	<string name="lesson11_p4">Форма <b>postfix</b> сначала использует значение переменной, прежде чем увеличивать её.</string>
	<string name="lesson11_hint">То же самое относится к оператору декремента.</string>
	<!--12-->
	<string name="lesson12_title">Строковые шаблоны</string>
	<string name="lesson12_p"><b>Строковые шаблоны</b> используются для вставки значения переменной в строку:</string>
	<string name="lesson12_p2">Все, что находится в фигурных скобках, начинающихся с знака $ (доллара), значение, и результат будет помещен в строку:</string>
	<string name="lesson12_p3">"Мы можем даже вызывать функции в выражении.

		\u0009\u0009Назовём функцию "<b>replace ()</b> для замены «is» на «was»:</string>
	<!--13-->
	<string name="lesson13_title">Время практики: основы</string>
	<string name="lesson13_p">Следующий код принимает в качестве ввода имя и возраст пользователя и печатает приветственное сообщение:</string>
	<string name="lesson13_p2">"Практикуйте свои навыки Kotlin, выполнив следующие задачи:

		\u0009\u00091. Напишите код, который принимает в качестве входных 3 целых числа и выводит их сумму.

		\u0009\u00092. Возьмите два числа с плавающей точкой в качестве входных данных и вставьте их разницу в вывод, используя строковые шаблоны."</string>
	<!--14-->
	<string name="lesson14_title">Операторы: if и else</string>
	<string name="lesson14_p">"Условные операторы выполняют разные действия в зависимости от того, какое логическое условие значение true или false.


		\u0009\u0009Используйте оператор "<b>if</b>", чтобы указать блок кода, который должен быть выполнен, если условие истинно.
		Давайте выведем приветствие «Good morning!», если значение переменной "<b>hour</b> меньше 12:</string>
	<string name="lesson14_p2">Что делать, если нам нужно вывести другое сообщение, если <b>hour</b>" не менее 12?
		Оператор "<b>else</b> используется для указания блока кода, который должен быть выполнен, если условие принимает значение false:</string>
	<string name="lesson14_p3">Условием для оператора <b>if</b> может быть любое значение типа Boolean:</string>
	<string name="lesson14_p4">В Kotlin <b>if</b> - это выражение, то есть оно возвращает значение. Это означает, что мы можем использовать, если присваивать значения переменной на основе условия. Пример:</string>
	<string name="lesson14_p5">Из-за этого в Kotlin нет тройного оператора, поскольку такое же поведение можно выполнить с помощью оператора <b>if</b>.</string>
	<string name="lesson14_hint">Когда оператор <b>if</b> используется как выражение, предложение <b>else</b> является обязательным.</string>
	<!--15-->
	<string name="lesson15_title">Операторы: if-else-if</string>
	<string name="lesson15_p">Может быть несколько операторов <b>else if</b>", когда требуется решение из трех или более действий.
		Последний оператор "<b>else</b> не является обязательным:</string>
	<string name="lesson15_hint">Вы можете добавить столько операторов <b>else if</b>, сколько вам необходимо.</string>
	<!--16-->
	<string name="lesson16_title">Логические операторы</string>
	<string name="lesson16_p">Логические операторы <b>&amp;&amp;</b> (И), <b>||</b> (ИЛИ), <b>!</b> (НЕ) используются для объединения условных операторов, образующих составное булево выражение, которое возвращает результат true или false.</string>
	<string name="lesson16_p2"><b>Оператор &amp;&amp;</b></string>
	<string name="lesson16_p3">Оператор <b>&amp;&amp;</b> (И) возвращает <b>true</b>, если все булевы выражения имеют значение <b>true</b>.</string>
	<string name="lesson16_hint">Оператор <b>==</b>" используется для проверки равенства.
		Не равенство проверяется с помощью оператора "<b>!=</b>.</string>
	<string name="lesson16_p4"><b>Оператор ||</b></string>
	<string name="lesson16_p5">Оператор <b>||</b> (ИЛИ) возвращает <b>true</b>, если любое из булевых выражений имеет значение <b>true</b>.</string>
	<string name="lesson16_p6"><b>Оператор !</b></string>
	<string name="lesson16_p7">Оператор <b>!</b>" (НЕ) возвращает обратное состояние булевого выражения.
		НЕ "<b>true</b> возвращает <b>false</b>, а НЕ <b>false</b> возвращает <b>true</b>".
		Следующий код выводит "<b>bye</b>, потому что <b>(b == 6)</b> имеет значение <b>false</b>, а затем изменяется на <b>true</b> с помощью оператора <b>!</b>:</string>
	<!--17-->
	<string name="lesson17_title">Выражение when</string>
	<string name="lesson17_p">В Kotlin оператор <b>when</b>" используется для проверки нескольких условий.
		Основной синтаксис оператора "<b>when</b> выглядит следующим образом:</string>
	<string name="lesson17_hint"><b>when</b> является эквивалентом оператора <b>switch</b> в других языках.</string>
	<string name="lesson17_p2"><b>when</b> соответствует его аргументу против всех ветвей последовательно до тех пор, пока не будет выполнено какое-либо условие ветвления.</string>
	<string name="lesson17_p3"><b>when</b> также может использоваться в качестве замены цепочки <b>if-else if</b>. Если аргумент не задан, условия ветвления являются просто булевыми выражениями:</string>
	<string name="lesson17_p4">Последний случай <b>else</b>, если все предыдущие случаи перед ним <b>false.</b> n n Несколько условий могут быть проверены в одном случае, если все они разделены запятыми.</string>
	<string name="lesson17_p5"><b>when</b> также может использоваться как выражение. Если он используется как выражение, значение удовлетворенной ветви становится значением общего выражения.</string>
	<string name="lesson17_hint2">Если <b>when</b> используется как выражение, ветвь <b>else</b> обязательна.</string>
	<!--18-->
	<string name="lesson18_title">Цикл while</string>
	<string name="lesson18_p"><b>loop</b>" - это блок кода, который будет повторяться до тех пор, пока не будет выполнено определенное условие.
		Оператор "<b>while</b>" выполняет операции повторно, пока выражение истинно.
		Общая форма:"</string>
	<string name="lesson18_p2">"Операторы в фигурных скобках будут повторяться до тех пор, пока не будет выполнено заданное условие.

		\u0009\u0009Например:"</string>
	<string name="lesson18_hint">Важно убедиться, что условие в конечном будет ложным. В противном случае мы встретим бесконечный цикл.</string>
	<!--19-->
	<string name="lesson19_title">Цикл do-while</string>
	<string name="lesson19_p">Цикл <b>do-while</b> сначала выполняет инструкции цикла. Это означает, что инструкции в цикле <b>do-while</b> всегда будут выполняться хотя бы один раз, даже если условие ложное.</string>
	<string name="lesson19_p2">Например:</string>
	<string name="lesson19_p3">Обратите внимание на точку с запятой в конце условия while.</string>
	<!--20-->
	<string name="lesson20_title">break и continue</string>
	<string name="lesson20_p">Оператор <b>break</b> завершает выполнение цикла.</string>
	<string name="lesson20_p2">Если вы хотите оставаться в цикле, но пропустите итерацию, используйте оператор <b>continue</b>:</string>
	<!--21-->
	<string name="lesson21_title">Массивы</string>
	<string name="lesson21_p"><b>Arrays</b>" представляет собой набор значений одного и того же типа.
		Когда вам нужно сохранить список значений, например чисел, вы можете сохранить их в массиве, а не объявлять отдельные переменные для каждого числа.
		Чтобы создать массив, мы можем использовать библиотечную функцию "<b>arrayOf ()</b> и передать ей значения элемента:</string>
	<string name="lesson21_p2">В массиве элементы упорядочиваются, и каждая из них имеет определенную и постоянную позицию, которая называется <b>index</b>".
		Чтобы получить доступ к элементу массива по его индексу, следует использовать оператор "<b>index []</b>.</string>
	<string name="lesson21_p3">Kotlin поддерживает специализированные классы для представления массивов примитивных типов. <b>ByteArray</b>, <b>ShortArray</b>, <b>IntArray</b>" и т.д.
		Ниже приведен пример объявления массива "<b>IntArray</b>. Обратите внимание на библиотечную функцию <b>intArrayOf ()</b>, которая создает и возвращает <b>IntArray</b>:</string>
	<string name="lesson21_hint">Обратите внимание, что элементы в массиве идентифицируются с <b>нулевого индекса</b>, что означает то, что индекс первого элемента <b>0</b>", а не один.
		Таким образом, максимальный индекс 5-элементного массива равен "<b>4</b>.</string>
	<!--22-->
	<string name="lesson22_title">Интервалы</string>
	<string name="lesson22_p">"Kotlin предоставляет уникальный тип для ряда значений.

		\u0009\u0009Диапазон имеет начало и конечное значение.


		\u0009\u0009Чтобы создать диапазон, вы можете использовать функцию "<b>rangeTo ()</b>:</string>
	<string name="lesson22_p2">Этот код определяет переменную диапазона <b>myRange</b>, содержащую значения от <b>1</b> до <b>10</b>" включительно.
		Диапазоны в Kotlin "<b>закрыты</b>", что означает, что начальное значение и конечное значение включены в диапазон.

		Чтобы создать уменьшающийся диапазон, используйте функцию "<b>downTo ()</b>:</string>
	<string name="lesson22_p3">decRange содержит значения: 8, 7, 6, 5, 4, 3, 2.</string>
	<string name="lesson22_p4"><b>Оператор ..</b>"
		Другой способ определения диапазона - использовать оператор .. (double dot):"</string>
	<string name="lesson22_p5">Оператор <b>in</b> позволяет проверить, принадлежит ли значение диапазону:</string>
	<string name="lesson22_p6">Аналогично, <b>!in</b> может использоваться для проверки того, не является ли число не принадлежащим диапазону.</string>
	<string name="lesson22_hint">Диапазоны аналогичны массивам, они представляют собой совокупности значений, которые можно было бы повторить.</string>
	<!--23-->
	<string name="lesson23_title">Цикл for</string>
	<string name="lesson23_p">Цикл <b>for</b> выполняет итерацию через коллекцию, а точнее через всё, что предоставляет итератор.\n
		Давайте напечатаем список значений в диапазоне.</string>
	<string name="lesson23_p2">Программа напечатает цифры от 1 до 10.\n
		На каждом шаге цикла переменная <b>x</b> будет содержать значение текущего элемента в диапазоне.\n\n
		Предположим, мы хотим перебрать диапазон четных чисел.\n
		Для этого мы можем определить диапазон <b>step</b>:</string>
	<!--24-->
	<string name="lesson24_title">Использование циклов с массивами</string>
	<string name="lesson24_p">Один из самых удобных способов организовать цикл по массиву-это цикл <b>for</b>:</string>
	<string name="lesson24_p2">Цикл while требует дополнительной индексной переменной для доступа к элементам массива.</string>
	<string name="lesson24_p3">Для итерации по массиву с индексом вы можете использовать цикл for с индексами массива</string>
	<!--25-->
	<string name="lesson25_title">Время практики: Циклы и Массивы</string>
	<string name="lesson25_p">Давайте посмотрим пример массивов и циклов в действии.\n
		Имея массив чисел с плавающей запятой, и мы хотим вычислить сумму элементов массива.</string>
	<string name="lesson25_p2">Мы объявили переменную сумму с начальным значением 0.0. Затем эта переменная используется для накопления суммы элементов массива с использованием цикла for.\n\n
		Ваше домашнее задание:\n
		1. Определите массив целых чисел и вычислите произведение его элементов.\n
		2. Определите диапазон чисел от 0 до 100 и выведите только нечетные числа в этом диапазоне.</string>
	<!--26-->
	<string name="lesson26_title">Функции</string>
	<string name="lesson26_p">Функция представляет собой блок кода, который может быть выполнен путем вызова функции.\n
		Объявление функции выполняется с использованием ключевого слова fun.\n
		Основной синтаксис функции в Kotlin выглядит следующим образом:</string>
	<string name="lesson26_p2">Функция имеет <b>имя</b>, которое используется для ссылки на неё, другими словами, на <b>вызов</b> функции.\n
		После имени появляется список функций <b>параметров</b>.\n
		Следуя скобкам, это тип данных, который должен быть возвращён функцией.\n
		Это может быть что угодно, если возвращаемая переменная соответствует типу.\n\n
		Когда функция вызывается, все операторы в фигурных скобках запускаются. Давайте объявим, а затем вызовем функцию, которая печатает приветственные сообщения:</string>
	<string name="lesson26_p3">Функция <b>greetUser ()</b> не принимает никаких параметров и не возвращает никакого значения, поскольку она только генерирует вывод.\n\n
		Определим функцию, которая принимает параметр Int и возвращает квадрат этого числа:</string>
	<string name="lesson26_p4">Ключевое слово return используется для возврата значения из функции.</string>
	<string name="lesson26_hint">Вы можете вызывать функцию столько раз, сколько захотите.\n
		Если функция возвращает значение, вы можете назначить её переменной, например: var a = square (8);\n</string>
	<!--27-->
	<string name="lesson27_title">Параметры функции</string>
	<string name="lesson27_p">Параметры функции используются для передачи значений функции.\n
		Параметры определяются в объявлении функции с использованием имени и типа параметра:</string>
	<string name="lesson27_p2">Мы объявили функцию greetUser (), которая принимает один параметр String с именем name.\n
		Теперь при вызове функции мы можем передать действительное значение параметра функции (также называемой аргументом). В приведенном выше примере «Max» - это аргумент, переданный функции.\n\n
		Функции могут принимать несколько параметров.\n
		Давайте объявим функцию, которая принимает два целых числа и печатает их сумму:</string>
	<string name="lesson27_p3">Одним из важнейших свойств функций является их способность возвращать значение.\n
		Давайте объявим функцию, взяв два целочисленных параметра и вернув их.\n
		Ключевое слово return используется для возврата значения:</string>
	<string name="lesson27_p4">Обратите внимание на дополнительный: Int после закрывающей скобки списка параметров в объявлении функции: он определяет тип возвращаемого значения функции.\n\n
		Мы можем напрямую включить возвращаемое значение функции в строку, используя строковые шаблоны:</string>
	<!--28-->
	<string name="lesson28_title">Аргументы функции по умолчанию</string>
	<string name="lesson28_p">Иногда удобно устанавливать значение по умолчанию для параметров функции. Эти значения по умолчанию используются, когда соответствующие аргументы опущены.\n\n
		Давайте объявим функцию с тремя параметрами, которая вычисляет и возвращает их сумму:</string>
	<string name="lesson28_p2">Давайте установим значение по умолчанию для третьего аргумента:</string>
	<string name="lesson28_p3">Теперь мы можем вызвать одну и ту же функцию только с двумя аргументами.\n\n
		<b>Именованные аргументы</b>\n
		Функциональные параметры можно назвать при вызове функций:</string>
	<string name="lesson28_p4">Это делает код более читаемым при вызове функций с несколькими параметрами.</string>
	<string name="lesson28_hint">Если параметр по умолчанию предшествует параметру без значения по умолчанию, значение по умолчанию может использоваться только путем вызова функции с именованными аргументами.</string>
	<!--29-->
	<string name="lesson29_title">Проверка типов и автоматическое копирование</string>
	<string name="lesson29_p">Kotlin предоставляет специальный тип Any.\n
		Этот тип позволяет хранить буквально все.\n
		Давайте объявим функцию, принимающую Any как параметр:</string>
	<string name="lesson29_p2">Как вы можете видеть в приведенном выше примере, функцию можно вызвать с помощью любого типа аргумента.\n\n
		Вы можете проверить тип аргументов с помощью оператора <b>is</b>.\n
		Давайте проверим, является ли аргумент <b>String</b> и выводит его длину:</string>
	<string name="lesson29_p3">Kotlin автоматически передает аргумент <b>Any</b> в правильный тип. В приведенном выше примере мы можем получить доступ к свойству <b>length</b> <b>String</b> без необходимости «конвертировать» <b>arg</b> в <b>String. </b></string>
	<!--30-->
	<string name="lesson30_title">Неверные типы</string>
	<string name="lesson30_p">В языках программирования значение null - это отсутствие значения.\n
		Если вы объявляете переменную в Kotlin, вы получаете значение, отличное от нуля, что означает, что переменная не может быть нулевой:</string>
	<string name="lesson30_p2">Этот код генерирует ошибку компиляции, потому что тип  <b>система Kotlin</b> пытается исключить <b>NullPointerException</b>. Это гарантирует доступ к свойствам и методам <b>str</b>:</string>
	<string name="lesson30_p3">Чтобы разрешить null, мы можем объявить переменную как nullable, используя знак вопроса, как показано ниже:</string>
	<string name="lesson30_p4">Приведенный выше код будет работать без ошибок.\n\n
		Тем не менее, теперь, пытаясь получить доступ к свойству на nullable <b>str</b>, возникает ошибка времени компиляции, так как теперь <b>str</b> может иметь значение null:</string>
	<string name="lesson30_p5">Чтобы получить <b>безопасный доступ</b> к значениям с нулевым значением, мы должны использовать оператор <b>?.</b> (называемый оператором <b>безопасного вызова</b>).</string>
	<string name="lesson30_hint"><b>?</b> может использоваться с любым типом, чтобы сделать его нулевым.</string>
	<!--31-->
	<string name="lesson31_title">Классы</string>
	<string name="lesson31_p"><b>Класс</b> похож на чертеж для объектов.\n
		Мы можем представить <b>класс</b> как эскиз (прототип) дома. Он содержит все детали дома (этажи, двери, окна и т.д.)\n
		На основе эскиза мы затем строим дом, который является <b>объектом</b>.\n\n
		Как дома, мы можем создать несколько <b>объектов</b> в <b>классе</b>.\n\n
		Для определения <b>класса</b> в Kotlin используется ключевое слово <b>class</b>:</string>
	<string name="lesson31_p2">Теперь мы можем объявлять объекты типа ClassName ():</string>
	<string name="lesson31_p3">Оба способа, показанные в приведенном выше коде, могут использоваться для создания объектов.</string>
	<string name="lesson31_hint">Каждый объект называется экземпляром класса. Процесс создания объектов называется <b>экземпляром</b>.</string>
	<!--32-->
	<string name="lesson32_title">Свойства</string>
	<string name="lesson32_p"><b>Классы</b> могут иметь <b>свойства</b>.\n
		Свойства похожи на обычные переменные, но объявлены в классе.\n
		Например:</string>
	<string name="lesson32_p2">Подобно регулярным переменным, свойства, объявленные с использованием ключевого слова <b>var</b>, являются <b>изменчивыми</b>, то есть они могут быть <b>переназначены</b>.\n
		Чтобы объявить свойство <b>только для чтения</b>, мы должны использовать ключевое слово <b>val</b>:</string>
	<string name="lesson32_p3">У каждого объекта есть свои уникальные значения для его свойств класса.\n
		Чтобы использовать свойства, просто обратитесь к нему по имени объекта экземпляра, используя <b>точку</b>:</string>
	<!--33-->
	<string name="lesson33_title">Функции-члены</string>
	<string name="lesson33_p">Класс может иметь объявление функций в своем теле.\n
		Эти функции называются <b>функциями-членов</b> (или <b>методы</b>).\n
		Они объявляются так же, как и обычные функции:</string>
	<string name="lesson33_p2">Функции-члены вызываются (вызываются) с точечной нотацией:</string>
	<string name="lesson33_p3">Мы можем получить доступ к свойствам класса из функций-членов, выполнить любые необходимые вычисления и т.д.\n
		Например, функция члена <b>printHello</b> () ниже печатает приветственное сообщение с использованием свойства <b>name</b> для класса:</string>
	<!--34-->
	<string name="lesson34_title">Getters и Setters</string>
	<string name="lesson34_p">Доступ к свойствам напрямую не является хорошей практикой.\n
		Иногда вам нужно проверить значение в случае недопустимого ввода или выполнить некоторые другие проверки или вычисления данных перед назначением или доступом к значению свойства.\n
		Предположим, что у нас есть класс <b>User</b> со свойством <b>age</b>:</string>
	<string name="lesson34_p2">Свойство объекта можно легко присвоить недопустимому значению. Вот пример:</string>
	<string name="lesson34_p3"><b>Getters</b> и <b>setters</b> помогают реализовать  <b>гибкость</b> в доступе к свойствам. Сеттер определяется с помощью ключевого слова <b>set</b> и позволяет определить поведение, когда значение присваивается свойству:</string>
	<string name="lesson34_p4">Ключевое слово <b>field</b> относится к свойству (<b>age в этом случае</b>).\n
		Каждый раз, когда клиентский код назначает новое значение для свойства age, в качестве аргумента вызывается <b>setter</b> со значением <b>value</b>. Код проверяет, больше ли значение, чем 0, и только затем присваивает его свойству.\n
		Следующий код будет выводить 0, так как значение <b>-12</b> не будет присвоено возрасту:</string>
	<string name="lesson34_p5">Getter, напротив, вызывается каждый раз, когда считывается значение свойства.\n
		Мы можем, например, добавить 2 к значению свойства <b>age</b> при его доступе:</string>
	<string name="lesson34_p6">Ключевое слово <b>field</b> относится к свойству (<b> age в этом случае</b>).\n
		Свойство может иметь как getter, так и setter.</string>
	<!--35-->
	<string name="lesson35_title">Первичный конструктор</string>
	<string name="lesson35_p">Конструктор - это удобный способ передать значения свойствам объекта во время их создания.\n
		Kotlin предоставляет первичный конструктор, который можно использовать для инициализации свойств при создании объекта.\n
		Вот как определяется первичный конструктор:</string>
	<string name="lesson35_p2">Следующим именем класса является основной конструктор. Основной конструктор является частью заголовка класса.\n
		Как вы можете видеть в приведенном выше коде, конструктор определяет свойство, называемое name типа String. Теперь, создавая объект, вы можете передать значение для свойства name в фигурных скобках.\n
		Ключевое слово конструктора можно опустить:</string>
	<string name="lesson35_hint">Первичные конструкторы могут объявлять свойства с помощью объявлений var или val. Множественные свойства должны быть разделены запятой.\n
		Первичные конструкторы не могут содержать код.</string>
	<!--36-->
	<string name="lesson36_title">Блок инициализатора</string>
	<string name="lesson36_p">Блок инициализатора может использоваться для автоматического запуска кода при создании объекта.\n
		Чтобы объявить блок инициализатора, используется ключевое слово init, за которым следуют фигурные скобки, содержащие код инициализации.\n\n
		Например:</string>
	<string name="lesson36_p2">Теперь, когда объект Student создан, код в блоке init будет запускаться автоматически.\n\n
		Класс может иметь более одного блока init. Они выполняются в том же порядке, что и в классе.\n
		Например:</string>
	<string name="lesson36_p3">Параметры первичного конструктора могут использоваться в блоках инициализатора.</string>
</resources>
